# A0116722M
###### DoLah\Commands\SearchDateTaskCommand.cpp
``` cpp
#include "Command.h"

namespace DoLah {
    //public
    SearchDateTaskCommand::SearchDateTaskCommand(std::tm from, std::tm to) {
        this->from = from;
        this->to = to;
    }

    SearchDateTaskCommand::~SearchDateTaskCommand() {

    }

    void SearchDateTaskCommand::execute() {
        this->calendar->searchDate(from, to);
    }

    void SearchDateTaskCommand::revert() {
    }

    //private
}
```
###### DoLah\Commands\SetUndoneTaskCommand.cpp
``` cpp
#include "Command.h"

namespace DoLah {
    //public
    SetUndoneTaskCommand::SetUndoneTaskCommand(int taskIndex) : taskIndex(taskIndex) {
    }

    SetUndoneTaskCommand::~SetUndoneTaskCommand() {
    }

    void SetUndoneTaskCommand::execute() {
        this->oldTask = this->calendar->getDoneList()[this->taskIndex];
        this->calendar->setDoneTask(this->taskIndex, false);
    };

    void SetUndoneTaskCommand::revert() {
        CalendarInverter::invertDone(oldTask, calendar);
    }

    //private
}
```
###### DoLah\Models\Calendar.cpp
``` cpp
    void Calendar::searchDate(std::tm from, std::tm to) {
        std::vector<AbstractTask*> results;

        for (int i = 0; i < taskList.size(); i++) {
            std::vector<std::tm> dates = AbstractTask::getDates(taskList[i]);
            if (dates.size() == 0) {
                continue;
            }
            if (TimeManager::compareTime(from, dates[0]) >= 0 && TimeManager::compareTime(dates[0], to) >= 0) {
                results.push_back(taskList.at(i));
            }
        }
        for (int i = 0; i < doneList.size(); i++) {
            std::vector<std::tm> dates = AbstractTask::getDates(doneList[i]);
            if (dates.size() == 0) {
                continue;
            }
            if (TimeManager::compareTime(from, dates[0]) > 0 && TimeManager::compareTime(dates[0], to) > 0) {
                results.push_back(doneList.at(i));
            }
        }
        this->searchedList = results;
    }

    void Calendar::sortTasks(std::vector<AbstractTask*> &unsortedTaskList) {
        std::sort(unsortedTaskList.begin(), unsortedTaskList.end(), AbstractTask::taskCompare);
        indexTasks(unsortedTaskList);
    }

    void Calendar::indexTasks(std::vector<AbstractTask*> &list, int startIndex) {
        for (size_t index = startIndex; index < list.size(); index++) {
            list[index]->setIndex(index);
        }
    }

    void Calendar::updateTaskExpiry() {
        for (size_t i = 0; i < this->taskList.size(); i++) {
            this->taskList[i]->updateExpired();
        }
    }
    
```
###### DoLah\Models\Task.cpp
``` cpp
    std::vector<std::tm> AbstractTask::getDates(AbstractTask *it) {
        std::vector<std::tm> dates;

        DoLah::FloatingTask* floatingTask = dynamic_cast<DoLah::FloatingTask*>(it);
        DoLah::EventTask* eventTask = dynamic_cast<DoLah::EventTask*>(it);
        DoLah::DeadlineTask* deadlineTask = dynamic_cast<DoLah::DeadlineTask*>(it);

        if (eventTask != NULL) {
            dates.push_back(eventTask->getEndDate());
            dates.push_back(eventTask->getStartDate());
        }

        if (deadlineTask != NULL) {
            dates.push_back(deadlineTask->getDueDate());
        }

        return dates;
    }
}
```
###### DoLah\Parser\CommandParser.cpp
``` cpp
#include "CommandParser.h"

namespace DoLah {
    std::vector<std::string> CommandParser::ADD = { "add" };
    std::vector<std::string> CommandParser::SEARCH = { "search", "find" };
    std::vector<std::string> CommandParser::DONE = { "done" };
    std::vector<std::string> CommandParser::UNDONE = { "undone" };
    std::vector<std::string> CommandParser::EDIT = { "edit" };
    std::vector<std::string> CommandParser::DELETE = { "delete", "del", "dl" };
    std::vector<std::string> CommandParser::CLEAR = { "clear" };
    std::vector<std::string> CommandParser::UNDO = { "undo" };
    std::vector<std::string> CommandParser::REDO = { "redo" };

    std::string CommandParser::TOO_MANY_ARGUMENTS_MESSAGE = "Too many arguments";
    std::string CommandParser::TOO_LITTLE_ARGUMENTS_MESSAGE = "Too little arguments";
    std::string CommandParser::INVALID_TASK_ID_ARGUMENT = "Invalid task ID given";

    std::vector<std::string> CommandParser::OUTDATED = { "outdated", "overdue" };

    CommandParser::CommandParser() {
    }


    CommandParser::~CommandParser() {
    }

    AddTaskCommand CommandParser::parseAdd(std::vector<std::string> inputArr) {
        if (inputArr.size() == 0) {
            throw std::invalid_argument(TOO_LITTLE_ARGUMENTS_MESSAGE);
        }

        AbstractTask* task = TaskParser::parseTask(inputArr);
        return AddTaskCommand(task);
    }

    SetDoneTaskCommand CommandParser::parseSetDone(std::vector<std::string> inputArr) {
        if (inputArr.size() == 0) {
            throw std::invalid_argument(TOO_LITTLE_ARGUMENTS_MESSAGE);
        } else if (inputArr.size() > 1) {
            throw std::invalid_argument(TOO_MANY_ARGUMENTS_MESSAGE);
        }

        int taskID;
        try {
            taskID = std::stoi(inputArr.at(0));
            if (taskID < 0) {
                throw std::invalid_argument(INVALID_TASK_ID_ARGUMENT);
            }
        } catch (std::invalid_argument e) {
            throw std::invalid_argument(INVALID_TASK_ID_ARGUMENT);
        }
        return SetDoneTaskCommand(taskID-1);
    }

    SetUndoneTaskCommand CommandParser::parseSetUndone(std::vector<std::string> inputArr) {
        if (inputArr.size() == 0) {
            throw std::invalid_argument(TOO_LITTLE_ARGUMENTS_MESSAGE);
        }
        else if (inputArr.size() > 1) {
            throw std::invalid_argument(TOO_MANY_ARGUMENTS_MESSAGE);
        }

        int taskID;
        try {
            taskID = std::stoi(inputArr.at(0));
            if (taskID < 0) {
                throw std::invalid_argument(INVALID_TASK_ID_ARGUMENT);
            }
        }
        catch (std::invalid_argument e) {
            throw std::invalid_argument(INVALID_TASK_ID_ARGUMENT);
        }
        return SetUndoneTaskCommand(taskID-1);
    }

    SearchTaskCommand CommandParser::parseSearch(std::vector<std::string> inputArr) {
        if (inputArr.size() == 0) {
            throw std::invalid_argument(TOO_LITTLE_ARGUMENTS_MESSAGE);
        }

        std::string arg = ParserLibrary::implode(inputArr, " ");

        return SearchTaskCommand(arg);
    }

    SearchDateTaskCommand CommandParser::parseSearchDate(std::vector<std::string> inputArr) {
        if (inputArr.size() == 0) {
            throw std::invalid_argument(TOO_LITTLE_ARGUMENTS_MESSAGE);
        }

        std::tm baseDate;
        std::tm searchDate;
        std::vector<std::tm> dates;

        if (inputArr.size() == 1 && ParserLibrary::inStringArray(OUTDATED, inputArr[0])) {
            baseDate = std::tm();
            searchDate = TimeManager::getCurrentTime();
        } else {
            dates = TaskTokenizer::findAndRemoveDate(inputArr);

            if (dates.size() == 1) {
                baseDate = TimeManager::getCurrentTime();
                searchDate = dates[0];
            } else if (dates.size() == 2) {
                baseDate = dates[0];
                searchDate = dates[1];
            } else {
                throw std::invalid_argument("");
            }
        }
        return SearchDateTaskCommand(baseDate, searchDate);
    }


    EditTaskCommand CommandParser::parseEdit(std::vector<std::string> inputArr) {
        if (inputArr.size() < 2) {
            throw std::invalid_argument(TOO_LITTLE_ARGUMENTS_MESSAGE);
        }

        int taskID;
        try {
            taskID = std::stoi(inputArr.at(0));
        } catch (std::invalid_argument e) {
            throw std::invalid_argument(INVALID_TASK_ID_ARGUMENT);
        }

        std::vector<std::string> subVec(inputArr.begin() + 1, inputArr.end());
        AbstractTask* task = TaskParser::parseTask(subVec);
        return EditTaskCommand(taskID-1, task);
    }


    DeleteTaskCommand CommandParser::parseDelete(std::vector<std::string> inputArr) {
        if (inputArr.size() == 0) {
            throw std::invalid_argument(TOO_LITTLE_ARGUMENTS_MESSAGE);
        } else if (inputArr.size() > 1) {
            throw std::invalid_argument(TOO_MANY_ARGUMENTS_MESSAGE);
        }

        int taskID;
        try {
            taskID = std::stoi(inputArr.at(0));
        } catch (std::invalid_argument e) {
            throw std::invalid_argument(INVALID_TASK_ID_ARGUMENT);
        }
        return DeleteTaskCommand(taskID-1);
    }


    ClearTaskCommand CommandParser::parseClear(std::vector<std::string> inputArr) {
        if (inputArr.size() > 0) {
            throw std::invalid_argument(TOO_MANY_ARGUMENTS_MESSAGE);
        }

        ClearTaskCommand command;
        return command;
    }


    UndoTaskCommand CommandParser::parseUndo(std::vector<std::string> inputArr) {
        if (inputArr.size() > 0) {
            throw std::invalid_argument(TOO_MANY_ARGUMENTS_MESSAGE);
        }

        UndoTaskCommand command;
        return command;
    }

    std::vector<std::string> CommandParser::pruneCommand(std::vector<std::string> lineArr) {
        lineArr.erase(lineArr.begin());
        return lineArr;
    }


    RedoTaskCommand CommandParser::parseRedo(std::vector<std::string> inputArr) {
        if (inputArr.size() > 0) {
            throw std::invalid_argument(TOO_MANY_ARGUMENTS_MESSAGE);
        }

        RedoTaskCommand command;
        return command;
    }


    AbstractCommand* CommandParser::parse(std::string input) {
        input = ParserLibrary::removeDoubleSpacing(input);
        std::vector<std::string> inputArr = ParserLibrary::explode(input, " ");
        std::string command = inputArr[0];

        if (ParserLibrary::inStringArray(ADD, command)) {
            inputArr = pruneCommand(inputArr);
            AddTaskCommand* command = new AddTaskCommand(parseAdd(inputArr));
            return command;
        } else if (ParserLibrary::inStringArray(SEARCH, command)) {
            inputArr = pruneCommand(inputArr);
            try {
                AbstractCommand* command = new SearchDateTaskCommand(parseSearchDate(inputArr));
                return command;
            } catch (std::invalid_argument e) {
                // continue
            }
            AbstractCommand* command = new SearchTaskCommand(parseSearch(inputArr));
            return command;
        } else if (ParserLibrary::inStringArray(DONE, command)) {
            inputArr = pruneCommand(inputArr);
            SetDoneTaskCommand* command = new SetDoneTaskCommand(parseSetDone(inputArr));
            return command;
        } else if (ParserLibrary::inStringArray(UNDONE, command)) {
            inputArr = pruneCommand(inputArr);
            SetUndoneTaskCommand* command = new SetUndoneTaskCommand(parseSetUndone(inputArr));
            return command;
        } else if (ParserLibrary::inStringArray(EDIT, command)) {
            inputArr = pruneCommand(inputArr);
            EditTaskCommand* command = new EditTaskCommand(parseEdit(inputArr));
            return command;
        } else if (ParserLibrary::inStringArray(DELETE, command)) {
            inputArr = pruneCommand(inputArr);
            DeleteTaskCommand* command = new DeleteTaskCommand(parseDelete(inputArr));
            return command;
        } else if (ParserLibrary::inStringArray(CLEAR, command)) {
            inputArr = pruneCommand(inputArr);
            ClearTaskCommand* command = new ClearTaskCommand(parseClear(inputArr));
            return command;
        } else if (ParserLibrary::inStringArray(UNDO, command)) {
            inputArr = pruneCommand(inputArr);
            UndoTaskCommand* command = new UndoTaskCommand(parseUndo(inputArr));
            return command;
        } else if (ParserLibrary::inStringArray(REDO, command)) {
            inputArr = pruneCommand(inputArr); 
            RedoTaskCommand* command = new RedoTaskCommand(parseRedo(inputArr));
            return command;
        } else {
            AddTaskCommand* command = new AddTaskCommand(parseAdd(inputArr));
            return command;
        }
    }
}

```
###### DoLah\Parser\CommandParser.h
``` h
#pragma once

#include <string>
#include <vector>
#include <chrono>
#include "assert.h"

#include "ParserLibrary.h"
#include "TaskParser.h"

#include "Commands/Command.h"
#include "Models/Task.h"


namespace DoLah {
    /**
    * @class CommandParser CommandParser.h Parser/CommandParser.h
    * @brief Receives a string and returns a Command object.
    *
    * If the input is invalid, it will throw invalid_argument exception.
    */
    class CommandParser {

    public:
        CommandParser();
        ~CommandParser();

        /**
         * Parse input string into a Command object.
         * @param[in]       input String to be parsed.
         * @return Command object.
         */
        static AbstractCommand* parse(std::string);

        /**
         * Parse input string vector into a AddTaskCommand.
         * @param[in]       inputArr String vector to be parsed.
         * @return AddTaskCommand object.
         */
        static AddTaskCommand parseAdd(std::vector<std::string>);

        /**
         * Parse input string vector into a SearchTaskCommand.
         * @param[in]       inputArr String vector to be parsed.
         * @return SearchTaskCommand object.
         */
        static SearchTaskCommand parseSearch(std::vector<std::string>);

        /**
         * Parse input string vector into a SearchDateTaskCommand.
         * @param[in]       inputArr String vector to be parsed.
         * @return SearchDateTaskCommand object.
         */
        static SearchDateTaskCommand parseSearchDate(std::vector<std::string>);

        /**
         * Parse input string vector into a SetDoneTaskCommand.
         * @param[in]       inputArr String vector to be parsed.
         * @return SetDoneTaskCommand object.
         */
        static SetDoneTaskCommand parseSetDone(std::vector<std::string>);
        
        /**
         * Parse input string vector into a SetUndoneTaskCommand.
         * @param[in]       inputArr String vector to be parsed.
         * @return SetUndoneTaskCommand object.
         */
        static SetUndoneTaskCommand parseSetUndone(std::vector<std::string>);

        /**
         * Parse input string vector into a EditTaskCommand.
         * @param[in]       inputArr String vector to be parsed.
         * @return EditTaskCommand object.
         */
        static EditTaskCommand parseEdit(std::vector<std::string>);
        
        /**
         * Parse input string vector into a DeleteTaskCommand.
         * @param[in]       inputArr String vector to be parsed.
         * @return DeleteTaskCommand object.
         */
        static DeleteTaskCommand parseDelete(std::vector<std::string>);
        
        /**
         * Parse input string vector into a ClearTaskCommand.
         * @param[in]       inputArr String vector to be parsed.
         * @return ClearTaskCommand object.
         */
        static ClearTaskCommand parseClear(std::vector<std::string>);
        
        /**
         * Parse input string vector into a UndoTaskCommand.
         * @param[in]       inputArr String vector to be parsed.
         * @return UndoTaskCommand object.
         */
        static UndoTaskCommand parseUndo(std::vector<std::string>);
        
        /**
         * Parse input string vector into a RedoTaskCommand.
         * @param[in]       inputArr String vector to be parsed.
         * @return RedoTaskCommand object.
         */
        static RedoTaskCommand parseRedo(std::vector<std::string>);

        /**
         * Prune the command from the string vector.
         * Currently the format is fixed, and thus always the first element is pruned.
         * @param[in]       inputArr String vector to be pruned
         * @return Pruned string vector.
         */
        // Fixed format ~ command is always at the front
        static std::vector<std::string> pruneCommand(std::vector<std::string> lineArr);
    private:
        /// @brief List of strings that indicates the string is an AddTaskCommand
        static std::vector<std::string> ADD;
        /// List of strings that indicates the string is a SearchTaskCommand
        static std::vector<std::string> SEARCH;
        /// List of strings that indicates the string is a DoneTaskCommand
        static std::vector<std::string> DONE;
        /// List of strings that indicates the string is an UndoneTaskCommand
        static std::vector<std::string> UNDONE;
        /// List of strings that indicates the string is an EditTaskCommand
        static std::vector<std::string> EDIT;
        /// List of strings that indicates the string is a DeleteTaskCommand
        static std::vector<std::string> DELETE;
        /// List of strings that indicates the string is a ClearTaskCommand
        static std::vector<std::string> CLEAR;
        /// List of strings that indicates the string is an UndoTaskCommand
        static std::vector<std::string> UNDO;
        /// List of strings that indicates the string is a RedohTaskCommand
        static std::vector<std::string> REDO;

        /// Message to be thrown when too many arguments are given for the command type.
        static std::string TOO_MANY_ARGUMENTS_MESSAGE;
        /// Message to be thrown when too little arguments are given for the command type.
        static std::string TOO_LITTLE_ARGUMENTS_MESSAGE;
        /// Message to be thrown when the task ID for edit or delete is nonsensual.
        static std::string INVALID_TASK_ID_ARGUMENT;

        /// Indicates that the search is looking for outdated tasks.
        static std::vector<std::string> OUTDATED;
    };
}
```
###### DoLah\Parser\DateTimeParser.cpp
``` cpp
#include "DateTimeParser.h"

namespace DoLah {
    int DateTimeParser::REJECT = -1;
    std::string DateTimeParser::CENTURY = "20";
    int DateTimeParser::MIN_IN_SECS = 60;
    int DateTimeParser::HOUR_IN_SECS = 3600;
    int DateTimeParser::DAY_IN_SECS = 86400;
    int DateTimeParser::WEEK_IN_SECS = 604800;
    int DateTimeParser::MONTH_IN_SECS = 2592000;
    int DateTimeParser::DEFAULT_TIME = 1439; // 23:59

    std::vector<std::string> DateTimeParser::DECORATORS = { "of", "in", "on", "by", "due", "at" };

    std::vector<std::string> DateTimeParser::DATE_PATTERN = {
        "monday|mon|mond",
        "tuesday|tue|tues",
        "wednesday|wed|weds",
        "thursday|thu|thur",
        "friday|fri|frid",
        "saturday|sat|satu",
        "sunday|sun|sund"
    };
    std::string DateTimeParser::DAY_APPENDIX_PATTERN = "(st|nd|rd|th)$";
    std::vector<std::string> DateTimeParser::MONTH_PATTERN = {
        "^(january|jan|01|1)$",
        "^(february|feb|02|2)$",
        "^(march|mar|03|3)$",
        "^(april|apr|04|4)$",
        "^(may|05|5)$",
        "^(june|jun|06|6)$",
        "^(july|jul|07|7)$",
        "^(august|aug|08|8)$",
        "^(september|sep|09|9)$",
        "^(october|oct|10)$",
        "^(november|nov|11)$",
        "^(december|dec|12)$"
    };
    std::vector<std::string> DateTimeParser::DATE_DIVIDERS = { "/", "-", "." };
    std::vector<std::string> DateTimeParser::PUNCTUATIONS = { "," };

    std::vector<std::string> DateTimeParser::TODAY_INDICATORS = { "today", "td" };
    std::vector<std::string> DateTimeParser::TOMORROW_INDICATORS = { "tomorrow", "tom", "tmr" };
    std::vector<std::string> DateTimeParser::SINGULAR_FORMATS = { "a", "an", "the", "one" };

    std::vector<std::string> DateTimeParser::DAY_DESCRIPTION_INDICATOR = { "d", "day", "days" };
    std::vector<std::string> DateTimeParser::WEEK_DESCRIPTION_INDICATOR = { "w", "week", "weeks", "wk", "wks" };
    std::vector<std::string> DateTimeParser::MONTH_DESCRIPTION_INDICATOR = { "m", "month", "months", "mon", "mons" };
    std::vector<std::string> DateTimeParser::YEAR_DESCRIPTION_INDICATOR = { "y", "year", "years", "yr", "yrs" };
    std::vector<std::string> DateTimeParser::HOUR_DESCRIPTION_INDICATOR = { "hour", "hours", "hr", "hrs" };
    std::vector<std::string> DateTimeParser::MIN_DESCRIPTION_INDICATOR = { "minute", "minutes", "min", "mins" };

    std::vector<std::string> DateTimeParser::NEXT_FORMATS = { "next", "coming" };

    std::string DateTimeParser::AM = "am";
    std::string DateTimeParser::PM = "pm";
    std::string DateTimeParser::TIME_DIVIDERS = ":";

    DateTimeParser::DateTimeParser() {
    }


    DateTimeParser::~DateTimeParser() {
    }



    int DateTimeParser::getDay(std::string str) {
        str = std::regex_replace(str, std::regex(DAY_APPENDIX_PATTERN), "");

        if (str.length() > 2) {
            return REJECT;
        } else if (!ParserLibrary::isDecimal(str)) {
            return REJECT;
        }

        return std::stoi(str);
    }

    int DateTimeParser::getMonth(std::string str) {
        std::string out;
        for (size_t m = 0; m < MONTH_PATTERN.size(); m++) {
            if (std::regex_match(str, std::regex(MONTH_PATTERN.at(m), std::regex_constants::icase))) {
                return (int)m;
            }
        }

        return REJECT;
    }

    int DateTimeParser::getYear(std::string year) {
        if (year.length() != 2 && year.length() != 4) {
            return REJECT;
        } else if (!ParserLibrary::isDecimal(year)) {
            return REJECT;
        }

        if (year.length() == 2) {
            year = CENTURY + year;
        }

        return std::stoi(year);
    }

    int DateTimeParser::getDate(std::string str) {
        std::string out;
        for (size_t d = 0; d < DATE_PATTERN.size(); d++) {
            if (std::regex_match(str, std::regex(DATE_PATTERN.at(d), std::regex_constants::icase))) {
                return (int)d;
            }
        }

        return REJECT;
    }

    int DateTimeParser::getTime(std::string str) {
        str = ParserLibrary::tolowercase(str);

        int time = 0;
        bool isTime = false;

        bool isPM = false;
        bool isAM = false;
        if (str.find(PM) != std::string::npos) {
            ParserLibrary::stringRemove(str, PM);
            isPM = true;
            isTime = true;
        } else if (str.find(AM) != std::string::npos) {
            ParserLibrary::stringRemove(str, AM);
            isAM = true;
            isTime = true;
        }
        
        std::vector<std::string> strArr = ParserLibrary::explode(str, TIME_DIVIDERS);

        int hour = std::stoi(strArr.at(0));
        if (isAM) {
            if (hour > 12) {
                throw std::invalid_argument("");
            } else if (isAM && hour == 12) {
                hour = 0;
            }
        }

        time = hour * 60;

        if (isPM) {
            if (hour < 12) {
                time += 12 * 60;
            }
        }

        if (strArr.size() > 1) {
            time += std::stoi(strArr.at(1));
            isTime = true;
        }

        if (!isTime) {
            throw std::invalid_argument("");
        }

        return time;
    }

    int DateTimeParser::getDateModifier(int date, bool notThisWeek) {
        std::tm current = TimeManager::getCurrentTime();

        int diff = date - current.tm_wday + 1;
        if (diff < 0) {
            diff = 7 + diff;
        } else if (notThisWeek) {
            diff += 7;
        }

        return diff;
    }

    int DateTimeParser::checkTimeModifier(std::vector<std::string> strArr) {
        int hourDiff = 0;
        int minDiff = 0;

        size_t size = strArr.size();

        int index = 0;
        std::string element;

        element = strArr.at(index++);

        if (size == 2) {
            if (ParserLibrary::inStringArray(NEXT_FORMATS, element)) { // next pattern
                element = strArr.at(index++);
                if (ParserLibrary::inStringArray(HOUR_DESCRIPTION_INDICATOR, element)) {
                    hourDiff = 1;
                } else if (ParserLibrary::inStringArray(MIN_DESCRIPTION_INDICATOR, element)) {
                    minDiff = 1;
                } else {
                    throw std::invalid_argument("");
                }
            } else if (ParserLibrary::isDecimal(element) ||
                ParserLibrary::inStringArray(SINGULAR_FORMATS, element)) { // 10 days, a week, etc
                int n = 0;
                if (ParserLibrary::inStringArray(SINGULAR_FORMATS, element)) {
                    n = 1;
                } else {
                    n = stoi(element);
                }

                element = strArr.at(index++);
                if (ParserLibrary::inStringArray(HOUR_DESCRIPTION_INDICATOR, element)) {
                    hourDiff = n;
                } else if (ParserLibrary::inStringArray(MIN_DESCRIPTION_INDICATOR, element)) {
                    minDiff = n;
                } else {
                    throw std::invalid_argument("");
                }
            } else {
                throw std::invalid_argument("");
            }
        } else {
            throw std::invalid_argument("");
        }

        std::tm current = TimeManager::getCurrentTime();
        std::tm modified = current;
        modified.tm_hour += hourDiff;
        modified.tm_min += minDiff;

        return TimeManager::compareTime(current, modified);
    }

    int DateTimeParser::checkDateModifier(std::vector<std::string> strArr, std::tm lowerBound) {
        int modifier = 0;
        std::tm current = TimeManager::getCurrentTime();

        int dayDiff = 0;
        int weekDiff = 0;
        int monthDiff = 0;
        int yearDiff = 0;

        size_t size = strArr.size();

        int index = 0;
        std::string element;

        element = strArr.at(index++);
        int date = getDate(element);
        if (size == 1) { // singleton format
            if (ParserLibrary::inStringArray(TODAY_INDICATORS, element)) {
                dayDiff = 0;
            } else if (ParserLibrary::inStringArray(TOMORROW_INDICATORS, element)) {
                dayDiff = 1;
            } else if (date != REJECT) {
                dayDiff = getDateModifier(date, false);
                
                std::tm modifiedDate = current;
                modifiedDate.tm_mday += dayDiff;
                mktime(&modifiedDate);
                modifier = TimeManager::compareTime(lowerBound, modifiedDate);
                if (modifier > 0) {
                    return modifier;
                } else {
                    modifiedDate.tm_mday += 7;
                    modifier = TimeManager::compareTime(current, modifiedDate);
                    return modifier;
                }
            } else {
                throw std::invalid_argument("");
            }
        } else if (size == 2) {
            if (ParserLibrary::inStringArray(NEXT_FORMATS, element)) { // next pattern
                element = strArr.at(index++);
                int date = getDate(element);
                if (date != REJECT) {
                    dayDiff = getDateModifier(date, true);
                } else {
                    if (ParserLibrary::inStringArray(DAY_DESCRIPTION_INDICATOR, element)) {
                        dayDiff = 1;
                    } else if (ParserLibrary::inStringArray(WEEK_DESCRIPTION_INDICATOR, element)) {
                        weekDiff = 1;
                    } else if (ParserLibrary::inStringArray(MONTH_DESCRIPTION_INDICATOR, element)) {
                        monthDiff = 1;
                    } else if (ParserLibrary::inStringArray(YEAR_DESCRIPTION_INDICATOR, element)) {
                        yearDiff = 1;
                    } else {
                        throw std::invalid_argument("");
                    }
                }
            } else if (ParserLibrary::isDecimal(element) ||
                ParserLibrary::inStringArray(SINGULAR_FORMATS, element)) { // 10 days, a week, etc
                int n = 0;
                if (ParserLibrary::inStringArray(SINGULAR_FORMATS, element)) {
                    n = 1;
                } else {
                    n = stoi(element);
                }

                element = strArr.at(index++);
                if (ParserLibrary::inStringArray(DAY_DESCRIPTION_INDICATOR, element)) {
                    dayDiff = n;
                } else if (ParserLibrary::inStringArray(WEEK_DESCRIPTION_INDICATOR, element)) {
                    weekDiff = n;
                } else if (ParserLibrary::inStringArray(MONTH_DESCRIPTION_INDICATOR, element)) {
                    monthDiff = n;
                } else if (ParserLibrary::inStringArray(YEAR_DESCRIPTION_INDICATOR, element)) {
                    yearDiff = n;
                } else {
                    throw std::invalid_argument("");
                }
            } else {
                throw std::invalid_argument("");
            }
        } else if (date != REJECT) {
            dayDiff = getDateModifier(date, false);
            std::vector<std::string> subVec(strArr.begin() + 1, strArr.end());

            subVec = formatArr(subVec);
            std::tm specifiedDay = classifyDate(subVec);

            if (TimeManager::compareTime(lowerBound, specifiedDay) < 0) {
                specifiedDay.tm_mday += 7;
                mktime(&specifiedDay);
            }

            modifier = TimeManager::compareTime(current, specifiedDay);;
            return modifier;
        } else {
            throw std::invalid_argument("");
        }

        std::tm modified = current;
        modified.tm_mday += dayDiff + 7 * weekDiff;
        modified.tm_mon += monthDiff;
        modified.tm_year += yearDiff;

        return TimeManager::compareTime(current, modified);
    }

    std::vector<std::string> DateTimeParser::formatArr(std::vector<std::string> strArr) {
        std::vector<std::string> cleanArr = ParserLibrary::removeElementsFromStringVector(strArr, DECORATORS);

        for (size_t i = 0; i < cleanArr.size(); i++) {
            for (size_t j = 0; j < PUNCTUATIONS.size(); j++) {
                boost::erase_all(cleanArr.at(i), PUNCTUATIONS.at(j));
            }
        }

        if (cleanArr.size() == 1) {
            std::string str = cleanArr.at(0);

            for (size_t i = 0; i < DATE_DIVIDERS.size(); i++) {
                cleanArr = ParserLibrary::explode(str, DATE_DIVIDERS.at(i));
                if (cleanArr.size() > 1) {
                    break;
                }
            }
        }

        if (cleanArr.size() == 0) {
            throw std::invalid_argument("");
        }

        return cleanArr;
    }

    std::tm DateTimeParser::toDateFormat(std::vector<std::string> strArr, std::tm lowerBound) {
        std::tm output = std::tm();

        bool done = false;
        bool hasTime = false;
        bool hasDay = false;

        bool hasLowerBound = (lowerBound.tm_year != std::tm().tm_year);
        if (hasLowerBound) {
            output = lowerBound;
            hasDay = true;
        } else {
            lowerBound = TimeManager::getCurrentTime();
        }

        std::vector<std::string> cleanArr = formatArr(strArr);

        int giventime = DEFAULT_TIME;
        for (size_t i = 0; i < cleanArr.size(); i++) {
            try {
                giventime = getTime(cleanArr.at(i));
                cleanArr.erase(cleanArr.begin() + i);
                if (cleanArr.size() == 0) {
                    done = true;
                }
                hasTime = true;
                break;
            } catch (std::invalid_argument e) {
                // if not continue
            }
        }

        if (!done) {
            try {
                int modifier = checkDateModifier(cleanArr, lowerBound);
                time_t t = time(NULL) + modifier;
                localtime_s(&output, &t);
                if (!TimeManager::isValidDate(output)) {
                    throw std::invalid_argument("");
                }
                done = true;
                hasDay = true;
            } catch (std::invalid_argument e) {
                // if not continue
            }
        }

        if (!done) {
            try {
                int modifier = checkTimeModifier(cleanArr);
                time_t t = time(NULL) + modifier;
                localtime_s(&output, &t);
                if (!TimeManager::isValidDate(output)) {
                    throw std::invalid_argument("");
                }
                done = true;

                giventime = output.tm_hour * 60 + output.tm_min;

                hasTime = true;
            } catch (std::invalid_argument e) {
                // if not continue
            }
        }

        if (!done) {
            try {
                output = classifyDate(cleanArr);
                hasTime = true;
                hasDay = true;
            } catch (std::invalid_argument e) {
                // if not continue
            }
        }

        output.tm_hour = giventime / 60;
        output.tm_min = giventime % 60;
        output.tm_sec = 0; // default

        // If only time is given and the time is behind the lowerBound,
        // take it as the next day.
        if (!hasDay && !hasTime) {
            throw std::invalid_argument("");
        } else if (!hasDay) {
            output = TimeManager::copyDay(TimeManager::getCurrentTime(), output);
            if (TimeManager::compareTime(lowerBound, output) < 0) {
                output.tm_mday += 1;
            }
        }

        std::mktime(&output);
        return output;
    }

    std::tm DateTimeParser::classifyDate(std::vector<std::string> strArr) {
        std::tm output;
        try {
            output = checkDMYformat(strArr);
        } catch (std::invalid_argument e) {
            try {
                output = checkMDYformat(strArr);
            } catch (std::invalid_argument e) {
                throw e;
            }
        }

        return output;
    }

    std::tm DateTimeParser::checkDMYformat(std::vector<std::string> strArr) {
        std::tm current = TimeManager::getCurrentTime();
        std::tm output = current;

        int day = -1;
        int month = -1;
        int year = -1;

        int monthModifier = 0;
        int yearModifier = 0;

        size_t size = strArr.size();
        day = getDay(strArr.at(0));
        if (day != REJECT) {
            output.tm_mday = day;
            if (size > 1) {
                month = getMonth(strArr.at(1));
                if (month != REJECT) {
                    output.tm_mon = month;
                    if (size > 2) {
                        year = getYear(strArr.at(2));
                        if (year != REJECT) {
                            output.tm_year = year - 1900;
                        } else {
                            throw std::invalid_argument("");
                        }
                    } else {
                        if (current.tm_mon > month) {
                            yearModifier += 1;
                        }
                    }
                } else {
                    throw std::invalid_argument("");
                }
            } else {
                if (current.tm_mday > day) {
                    monthModifier += 1;
                }
            }
        } else {
            throw std::invalid_argument("");
        }

        if (!TimeManager::isValidDate(output)) {
            throw std::invalid_argument("");
        }

        output.tm_mon += monthModifier;
        output.tm_year += yearModifier;

        return output;
    }

    std::tm DateTimeParser::checkMDYformat(std::vector<std::string> strArr) {
        std::tm current = TimeManager::getCurrentTime();
        std::tm output = current;

        int day = -1;
        int month = -1;
        int year = -1;

        int monthModifier = 0;
        int yearModifier = 0;

        size_t size = strArr.size();
        month = getMonth(strArr.at(0));
        if (month != REJECT) {
            output.tm_mon = month;
            if (size <= 1) {
                throw std::invalid_argument("");
            }
            day = getDay(strArr.at(1));
            if (day != REJECT) {
                output.tm_mday = day;
                if (size > 2) {
                    year = getYear(strArr.at(2));
                    if (year != REJECT) {
                        output.tm_year = year - 1900;
                    } else {
                        throw std::invalid_argument("");
                    }
                } else {
                    if (current.tm_mon > month) {
                        yearModifier += 1;
                    }
                }
            } else {
                throw std::invalid_argument("");
            }
        } else {
            throw std::invalid_argument("");
        }

        if (!TimeManager::isValidDate(output)) {
            throw std::invalid_argument("");
        }

        output.tm_mon += monthModifier;
        output.tm_year += yearModifier;

        return output;
    }
}
```
###### DoLah\Parser\DateTimeParser.h
``` h
#pragma once

#include <string>
#include <vector>
#include <regex>
#include <iterator>

#include "boost/algorithm/string/erase.hpp"

#include "ParserLibrary.h"
#include "TimeManager.h"

namespace DoLah {
    /**
    * @class DateTimeParser DateTimeParser.h Parser/DateTimeParser.h
    * @brief Static library to handle conversion from string vector to std::tm.
    *
    * Throws invalid_argument exception if the given list of string cannot be converted.
    */
    class DateTimeParser {
    public:
        DateTimeParser();
        ~DateTimeParser();

        /**
         * Converts string array into std::tm.
         * It will handle many different kinds of formats for a degree of NLP.
         * @param[in]   strArr String array to be converted
         * @param[in]   lowerBound std::tm that indicates the lowerbound for the time.
         *              By default, the current time is set as the lowerbound.
         * @return std::tm object
         */
        static std::tm toDateFormat(std::vector<std::string>, std::tm = std::tm());

        /**
         * Check the input string and convert it into corresponding day.
         * If not valid, global variable int REJECT will be returned.
         * @param[in]   str String to be converted
         * @return Day int
         */
        static int getDay(std::string);

        /**
         * Check the input string and convert it into corresponding month.
         * If not valid, global variable int REJECT will be returned.
         * @param[in]   str String to be converted
         * @return Month int
         */
        static int getMonth(std::string);

        /**
         * Check the input string and convert it into corresponding year.
         * If not valid, global variable int REJECT will be returned.
         * @param[in]   str String to be converted
         * @return Year int
         */
        static int getYear(std::string);

        /**
         * Check the input string and convert it into corresponding int that represents the date.
         * If not valid, global variable int REJECT will be returned.
         * @param[in]   str String to be converted
         * @return Date int
         */
        static int getDate(std::string);

        /**
         * Check the input string and convert it into corresponding time represented as seconds since the Epoch.
         * If not valid, global variable int REJECT will be returned.
         * @param[in]   str String to be converted
         * @return Time int
         */
        static int getTime(std::string);

        /**
         * Removes unnecessary elements that is unrelated to date time parsing from the string array.
         * @param[in]   strArr String vector to be formatted
         * @return Formatted string vector
         */
        static std::vector<std::string> formatArr(std::vector<std::string>);

        /**
         * Handles dates such as Monday
         * @param[in]   date Expressed in int value as the std::tm
         * @param[in]   notThisWeek True if the date is not this week
         * @return The number of days difference compared to the current day.
         */
        static int getDateModifier(int, bool);
        
        /**
         * Deals with the expressions that describe relative date.
         * e.x. today, tomorrow, 10 days, 1 week, next Thursday...
         * @param[in]   strArr The string vector list to be evaluated.
         * @param[in]   lowerBound Returned day is above this lowerbound.
         * @return The number of seconds difference compared to the current time.
         */
        static int checkDateModifier(std::vector<std::string>, std::tm);

        /**
         * Deals with the expressions that describe relative time.
         * e.x. next hour, 30 minutes...
         * @param[in]   strArr The string vector list to be evaluated.
         * @return The number of seconds difference compared to the current time.
         */
        static int checkTimeModifier(std::vector<std::string>);

        /**
         * Check the specific date format in DMY and MDY format
         * e.x. 25 December 2015
         * @param[in]   strArr The string vector list to be evaluated.
         * @return Date in std::tm format.
         */
        static std::tm classifyDate(std::vector<std::string>);

        /**
         * Check Day Month Year format and convert it into date format
         * @param[in]   strArr The string vector list to be evaluated.
         * @return Date in std::tm format.
         */
        static std::tm checkDMYformat(std::vector<std::string>);
        
        /**
         * Check Month Day Year format and convert it into date format
         * @param[in]   strArr The string vector list to be evaluated.
         * @return Date in std::tm format.
         */
        static std::tm checkMDYformat(std::vector<std::string>);
    private:
        static int REJECT; /// Arbitrary int value to indicates REJECT in any classification.
        static std::string CENTURY; /// For year described in 2 digits, 20 will be added. e.x. 15 -> 2015
        static int MIN_IN_SECS; /// Minute in Seconds
        static int HOUR_IN_SECS;  /// Hour in Seconds
        static int DAY_IN_SECS;  /// Day in Seconds
        static int WEEK_IN_SECS;  /// Week in Seconds
        static int MONTH_IN_SECS;  /// Month in Seconds
        static int DEFAULT_TIME; /// If time is not specified, 23:59 is the default time.

        static std::vector<std::string> DATE_PATTERN; /// Monday, Mon
        static std::vector<std::string> MONTH_PATTERN; /// 12, December, Dec

        static std::string DAY_APPENDIX_PATTERN; /// 1st, 2nd, 3rd, 4th
        static std::vector<std::string> DECORATORS; /// 25th of Dec
        static std::vector<std::string> PUNCTUATIONS; /// Sunday, 17th of March
        static std::vector<std::string> DATE_DIVIDERS; /// 25.12.2015, 25/12/2015, 25-12-2015

        static std::vector<std::string> TODAY_INDICATORS; /// today
        static std::vector<std::string> TOMORROW_INDICATORS; /// tomorrow
        static std::vector<std::string> SINGULAR_FORMATS; /// a, an, the, one
        static std::vector<std::string> DAY_DESCRIPTION_INDICATOR; /// 10 days
        static std::vector<std::string> WEEK_DESCRIPTION_INDICATOR; /// 2 weeks
        static std::vector<std::string> MONTH_DESCRIPTION_INDICATOR; /// 3 months
        static std::vector<std::string> YEAR_DESCRIPTION_INDICATOR; /// 4 year
        static std::vector<std::string> HOUR_DESCRIPTION_INDICATOR; /// 3 hours
        static std::vector<std::string> MIN_DESCRIPTION_INDICATOR; /// 30 mins
        static std::vector<std::string> NEXT_FORMATS; /// next, coming

        static std::string AM; /// am
        static std::string PM; /// pm
        static std::string TIME_DIVIDERS; /// 12:30
    };
}
```
###### DoLah\Parser\ParserLibrary.cpp
``` cpp
#include "ParserLibrary.h"

namespace DoLah {

    ParserLibrary::ParserLibrary() {
    }


    ParserLibrary::~ParserLibrary() {
    }


    std::string ParserLibrary::strip(std::string str) {
        if (str.length() == 0) return str;

        std::string out = str;
        size_t from = 0;
        for (; from < out.length() && out.at(from) == ' '; from++) {
        }

        size_t to = out.length() - 1;
        for (; to > from && out.at(to) == ' '; to--) {
        }

        out = out.substr(from, to - from + 1);
        return out;
    }


    std::vector<std::string> ParserLibrary::explode(std::string input, std::string delimeter) {
        std::string line = strip(input);
        if (line.length() == 0) {
            return {};
        }

        std::vector<std::string> out;
        size_t from = 0;
        size_t to;

        while ((to = line.find(delimeter, from)) != -1) {
            out.push_back(line.substr(from, to - from));
            from = to + 1;
        }
        out.push_back(line.substr(from, line.size() - from));

        return out;
    }

    std::string ParserLibrary::implode(std::vector<std::string> line, std::string delimeter) {
        std::string out = "";

        for (size_t i = 0; i < line.size(); i++) {
            if (i > 0) {
                out += delimeter;
            }
            out += line.at(i);
        }

        return out;
    }


    std::string ParserLibrary::vectorToString(std::vector<std::string> vec) {
        std::string str = "{ ";
        for (int i = 0; i < (int)vec.size(); i++) {
            str += vec.at(i);
            if (i < (int)vec.size() - 1) {
                str += +", ";
            }
        }
        str += " }";
        return str;
    }

    std::string ParserLibrary::tolowercase(std::string str) {
        std::transform(str.begin(), str.end(), str.begin(), ::tolower);
        return str;
    }

    bool ParserLibrary::inStringArray(std::vector<std::string> arr, std::string str) {
        return std::find(arr.begin(), arr.end(), ParserLibrary::tolowercase(str)) != arr.end();
    }

    size_t ParserLibrary::getIndexInStringArray(std::vector<std::string> arr, std::string str) {
        size_t pos = std::find(arr.begin(), arr.end(), str) - arr.begin();
        return pos;
    }

    std::vector<std::string> ParserLibrary::stringVectorUnique(std::vector<std::string> vector) {
        std::vector<std::string>::iterator it;
        it = std::unique(vector.begin(), vector.end());
        vector.resize(std::distance(vector.begin(), it));
        return vector;
    }


    bool ParserLibrary::isDecimal(std::string str) {
        for (size_t i = 0; i < str.length(); i++) {
            if (str.at(i) > '9' || str.at(i) < '0') {
                return false;
            }
        }
        return true;
    }


    std::string ParserLibrary::stringRemove(std::string str, std::string substr) {
        size_t f = str.find(substr);
        if (f != std::string::npos) {
            str.replace(f, substr.length(), "");
        }
        return str;
    }

    std::string ParserLibrary::stringRemoveAll(std::string str, std::string substr) {
        size_t f = str.find(substr);
        while (f != std::string::npos) {
            str.replace(f, substr.length(), "");
            f = str.find(substr);
        }
        return str;
    }

    std::string ParserLibrary::removeDoubleSpacing(std::string str) {
        std::string substr = "  ";
        return stringRemoveAll(str, substr);
    }

    

    std::vector<std::string> ParserLibrary::removeElementsFromStringVector(std::vector<std::string> origin, std::vector<std::string> list) {
        for (size_t i = 0; i < list.size(); i++) {
            for (size_t j = 0; j < origin.size(); j++) {
                if (tolowercase(origin.at(j)) == tolowercase(list.at(i))) {
                    origin.erase(origin.begin() + j);
                }
            }
        }
        return origin;
    }
}
```
###### DoLah\Parser\ParserLibrary.h
``` h
#pragma once

#include <string>
#include <vector>
#include <algorithm>

namespace DoLah {

    /**
    * @class ParserLibrary ParserLibrary.h Parser/ParserLibrary.h
    * @brief A library consists of general functions.
    *
    * These functions are widly used in parse component.
    */
    class ParserLibrary {
    public:
        ParserLibrary();
        ~ParserLibrary();

        /**
         * Equivalent to strip of Java. Remove empty spaces before and after the string.
         * @param[in]   str String to be cleaned
         * return Clean string
         */
        static std::string strip(std::string);

        /**
         * Equivalent to explode of PHP or split of Java. Split string on each delimeters.
         * @param[in]   line String to be split
         * return Vector list of substring
         */
        static std::vector<std::string> explode(std::string, std::string);
        
        /**
         * Equivalent to implode of PHP or merge of Java. Put elements together with delimeter between.
         * @param[in]   line String vector list to be merged
         * return Merged string
         */
        static std::string implode(std::vector<std::string>, std::string);

        /**
         * Implode string vector list with an empty space.
         * @param[in]   vec String vector list to be converted.
         * return Merged string
         */
        static std::string vectorToString(std::vector<std::string> vec);

        /**
         * Make all the alphabets in the string into lowercase.
         * @param[in]   str String to be converted.
         * return String with all alphabet in lowercase.
         */
        static std::string tolowercase(std::string str);

        /**
         * Check whether the given string vector list contains the string or not.
         * @param[in]   arr String vector list
         * @param[in]   str String to be found
         * return True if it is in the list.
         */
        static bool inStringArray(std::vector<std::string> arr, std::string str);

        /**
         * Get the index of the element in the list.
         * @param[in]   arr String vector list
         * @param[in]   str String to be found
         * return Index of the element. If there is no such element, returns std::npos.
         */
        static size_t ParserLibrary::getIndexInStringArray(std::vector<std::string>, std::string);

        /**
         * Clean up duplicates from the string vector list.
         * @param[in]   vector String vector list to be cleaned.
         * return Stirng vector list with unique elements.
         */
        static std::vector<std::string> stringVectorUnique(std::vector<std::string> vector);

        /**
         * Check whether that string is a decimal integer or not.
         * @param[in]   str String to be checked.
         * return True if it is a decimal integer.
         */
        static bool isDecimal(std::string str);

        /**
         * Remove the first occurance of the substring from the string.
         * @param[in]   str Original string.
         * @param[in]   substr Substring to be removed.
         * return Pruned string.
         */
        static std::string stringRemove(std::string str, std::string substr);

        /**
         * Remove the all occurances of the substring from the string.
         * @param[in]   str Original string.
         * @param[in]   substr Substring to be removed.
         * return Pruned string.
         */
        static std::string stringRemoveAll(std::string str, std::string substr);

        /**
         * Removes the double spacing repeatedly until there is only single spacing.
         * @param[in]   str String to be cleaned up.
         * @return Clean string
         */
        static std::string removeDoubleSpacing(std::string);

        /**
         * Removes the elements of the list 
         * @param[in]   origin String vector list to be cleaned.
         * @param[in]   list List of string vector list that needs to be cleaned from the origin.
         * @return Clean string vector list.
         */
        static std::vector<std::string> removeElementsFromStringVector(std::vector<std::string>, std::vector<std::string>);
    };

}
```
###### DoLah\Parser\TaskParser.cpp
``` cpp
#include "TaskParser.h"

namespace DoLah {
    TaskParser::TaskParser() {
    }


    TaskParser::~TaskParser() {
    }

    AbstractTask* TaskParser::parseTask(std::vector<std::string> inputArr) {
        std::vector<std::tm> dates = TaskTokenizer::findAndRemoveDate(inputArr);
        std::vector<std::string> tags = TaskTokenizer::findTags(inputArr);
        std::string description = TaskTokenizer::findDescription(inputArr);

        if (dates.size() == 1) {
            DeadlineTask* task = new DeadlineTask();
            task->setName(description);
            task->setTags(tags);
            task->setDueDate(dates.at(0));
            return task;
        } else if (dates.size() == 2) {
            EventTask* task = new EventTask();
            task->setName(description);
            task->setTags(tags);
            task->setStartDate(dates.at(0));
            task->setEndDate(dates.at(1));
            return task;
        }

        FloatingTask* task = new FloatingTask();
        task->setName(description);
        task->setTags(tags);
        return task;
    }
}

```
###### DoLah\Parser\TaskParser.h
``` h
#pragma once

#include "Models/Task.h"
#include "TaskTokenizer.h"

namespace DoLah {
    /**
    * @class TaskParser TaskParser.h TaskParser.h
    * @brief Provides function to parse string vector list into a Task object.
    */
    class TaskParser {
    public:
        TaskParser();
        ~TaskParser();

        /**
         * Convert input string vector list into a task object
         * @param[in]   inputArr String vector list to be converted into a task object
         * @return Parsed task object
         */
        static AbstractTask* parseTask(std::vector<std::string>);
    };
}
```
###### DoLah\Parser\TaskTokenizer.cpp
``` cpp
#include "TaskTokenizer.h"


namespace DoLah {
    std::vector<std::string> TaskTokenizer::EVENT_INDICATOR = { "in", "on", "from", "between" };
    std::vector<std::string> TaskTokenizer::DEADLINE_INDICATOR = { "in", "on", "by", "due", "at" };
    std::vector<std::string> TaskTokenizer::EVENT_SEPARATOR = { "to", "~", "until" };
    std::string TaskTokenizer::TAG_INDICATOR = "#";
    int TaskTokenizer::DEFAULTTMYEAR = 0; // represents 1900

    TaskTokenizer::TaskTokenizer() {
    }


    TaskTokenizer::~TaskTokenizer() {
    }

    std::vector<std::string> TaskTokenizer::findTags(std::vector<std::string> lineArr) {
        std::vector<std::string> tags;
        std::vector<std::string> moretags;

        for (size_t i = 0; i < lineArr.size(); i++) {
            moretags = ParserLibrary::explode(lineArr.at(i), TAG_INDICATOR);
            tags.insert(tags.begin(), moretags.begin() + 1, moretags.end());
        }

        for (size_t i = 0; i < tags.size(); i++) {
            tags.at(i) = ParserLibrary::tolowercase(tags.at(i));
        }

        tags = ParserLibrary::stringVectorUnique(tags);

        return tags;
    }

    std::string TaskTokenizer::findDescription(std::vector<std::string> lineArr) {
        return ParserLibrary::implode(lineArr, " ");
    }

    std::vector<std::tm> TaskTokenizer::findDeadline(std::vector<std::string> subVec) {
        std::tm current = TimeManager::getCurrentTime();
        std::tm dueDate;

        dueDate = DateTimeParser::toDateFormat(subVec);

        if (TimeManager::compareTime(current, dueDate) < 0) {
            throw std::invalid_argument("");
        }

        return { dueDate };
    }

    std::vector<std::tm> TaskTokenizer::findEvent(std::vector<std::string> startDateArr, std::vector<std::string> endDateArr) {
        std::tm current = TimeManager::getCurrentTime();
        std::tm startdate = DateTimeParser::toDateFormat(startDateArr);
        std::tm enddate = DateTimeParser::toDateFormat(endDateArr, startdate);

        if (startdate.tm_year == DEFAULTTMYEAR && startdate.tm_year == DEFAULTTMYEAR) {
            TimeManager::copyDay(current, startdate);
            TimeManager::copyDay(current, enddate);
            if (TimeManager::compareTime(startdate, enddate) < 0) {
                enddate.tm_mon += 1;
                mktime(&enddate);
            }
        } else if (startdate.tm_year == DEFAULTTMYEAR) {
            TimeManager::copyDay(enddate, startdate);
            if (TimeManager::compareTime(startdate, enddate) < 0) {
                throw std::invalid_argument("");
            }
        } else if (enddate.tm_year == DEFAULTTMYEAR) {
            TimeManager::copyDay(startdate, enddate);
            if (TimeManager::compareTime(startdate, enddate) < 0) {
                enddate.tm_mon += 1;
                mktime(&enddate);
            }
        }

        // time cannot backflow!
        if (TimeManager::compareTime(startdate, enddate) < 0) {
            throw std::invalid_argument("");
        }

        return { startdate, enddate };
    }

    std::vector<std::tm> TaskTokenizer::findDate(std::vector<std::string> lineArr) {
        int index = 0;
        std::vector<std::tm> output;

        if (ParserLibrary::inStringArray(EVENT_INDICATOR, ParserLibrary::tolowercase(lineArr.at(index)))) {
            size_t indicatorIndex = ParserLibrary::getIndexInStringArray(EVENT_INDICATOR, ParserLibrary::tolowercase(lineArr.at(index)));
            std::vector<std::string> subVec(lineArr.begin() + index + 1, lineArr.end());
            for (size_t j = 0; j < subVec.size(); j++) {
                if (ParserLibrary::inStringArray(EVENT_SEPARATOR, ParserLibrary::tolowercase(subVec.at(j)))) {
                    std::vector<std::string> startDateArr(subVec.begin(), subVec.begin() + j);
                    std::vector<std::string> endDateArr(subVec.begin() + j + 1, subVec.end());

                    output = findEvent(startDateArr, endDateArr);
                    break;
                }
            }
        }

        if (output.size() == 0 && ParserLibrary::inStringArray(DEADLINE_INDICATOR, ParserLibrary::tolowercase(lineArr.at(index)))) {
            std::vector<std::string> subVec(lineArr.begin() + index + 1, lineArr.end());

            output = findDeadline(subVec);
        }

        if (output.size() == 0) {
            throw std::invalid_argument("");
        }

        return output;
    }

    std::vector<std::tm> TaskTokenizer::findAndRemoveDate(std::vector<std::string> &lineArr) {
        std::tm current = TimeManager::getCurrentTime();
        std::vector<std::tm> output;

        std::vector<std::string> prunedArr = lineArr;

        for (size_t index = 0; index < lineArr.size(); index++) {
            try {
                std::vector<std::string> subVec(lineArr.begin() + index, lineArr.end());
                output = findDate(subVec);
                prunedArr = std::vector<std::string>(lineArr.begin(), lineArr.begin() + index);
            } catch (std::invalid_argument e) {
                // continue
            }
        }

        lineArr = prunedArr;
        return output;
    }
}
```
###### DoLah\Parser\TaskTokenizer.h
``` h
#include <string>
#include <vector>

#include "ParserLibrary.h"
#include "DateTimeParser.h"

#pragma once
namespace DoLah {
    /**
    * @class TokenTokenizer TaskTokenizer.h Parser/TaskTokenizer.h
    * @brief Tokenize the string vector list into tokens that make up Task object.
    */
    class TaskTokenizer {
    public:
        TaskTokenizer();
        ~TaskTokenizer();

        /**
         * Find the date from the string vector list and returns it as well as removing the date portion from the referenced list.
         * @param[in, out]  lineArr Reference of a string vector list to be evaluated. Date portion will be removed.
         * @return Date found in std::tm format.
         */
        static std::vector<std::tm> findAndRemoveDate(std::vector<std::string>&);

        /**
         * Find the description from the string vector list.
         * @param[in]   lineArr String vector list to be evaluated.
         * @return String that represents the description.
         */
        static std::string findDescription(std::vector<std::string>);

        /**
         * Find the tags from the string vector list.
         * @param[in]   lineArr String vector list to be evaluated.
         * @return String vector list of tags.
         */
        static std::vector<std::string> findTags(std::vector<std::string>);
        
    private:
        static std::vector<std::string> DEADLINE_INDICATOR;
        static std::vector<std::string> EVENT_INDICATOR;
        static std::vector<std::string> EVENT_SEPARATOR;
        static std::string SCHEDULE_INDICATOR;
        static std::vector<std::string> SCHEDULE_SEPARATOR;
        static std::string TAG_INDICATOR;
        static int DEFAULTTMYEAR;
        
        /**
         * Find all dates from the given string vector list.
         * @param[in]   lineArr String vector list to be evaluated.
         * @return Vector list of time in std::tm format.
         */
        static std::vector<std::tm> TaskTokenizer::findDate(std::vector<std::string>);

        /**
         * Find date for deadline task.
         * @param[in]   lineArr String vector list to be evaluated.
         * @return Vector list of time in std::tm format.
         */
        static std::vector<std::tm> TaskTokenizer::findDeadline(std::vector<std::string>);

        /**
         * Find dates for event task.
         * @param[in]   lineArr String vector list to be evaluated.
         * @return Vector list of time in std::tm format.
         */
        static std::vector<std::tm> TaskTokenizer::findEvent(std::vector<std::string>, std::vector<std::string>);
    };
}
```
###### DoLah\TimeManager.cpp
``` cpp
#include "TimeManager.h"

namespace DoLah {
    TimeManager::TimeManager() {
    }

    TimeManager::~TimeManager() {
    }

    std::tm TimeManager::copyDay(std::tm from, std::tm to) {
        to.tm_year = from.tm_year;
        to.tm_mon = from.tm_mon;
        to.tm_mday = from.tm_mday;

        return to;
    }

    bool TimeManager::isValidDate(std::tm date) {
        std::tm checkTime = date;
        std::mktime(&checkTime);
        if (checkTime.tm_year == -1 && checkTime.tm_mon == -1 && checkTime.tm_mday == -1) {
            throw std::invalid_argument("");
        }
        // IF mktime changes the time format, that means the input date was wrong!
        // ex. 31st April becomes 1st May
        if (date.tm_mday != checkTime.tm_mday
            || date.tm_mon != checkTime.tm_mon
            || date.tm_year != checkTime.tm_year) {
            return false;
        }
        return true;
    }

    std::tm TimeManager::getCurrentTime() {
        time_t t = time(0);
        std::tm current;
        localtime_s(&current, &t);
        
        return current;
    }

    int TimeManager::compareTime(std::tm startdate, std::tm enddate) {
        return difftime(mktime(&enddate), mktime(&startdate));
    }

}
```
###### DoLah\TimeManager.h
``` h
#pragma once

#include <ctime>
#include <string>

namespace DoLah {
    /**
    * @class TimeManager TimeManager.h TimeManager.h
    * @brief A library consists of general functions related to time manipulation in std::tm.
    *
    * These functions are widly used in parse component.
    */
    class TimeManager {
    public:
        TimeManager();
        ~TimeManager();

        static std::tm copyDay(std::tm, std::tm);
        
        /**
         * Check whether the given std::tm represents a valid date or not.
         * For example, 31st of April is an invalid date.
         * @param[in]   date Date to be evaluated.
         * return True is it is a valid date.
         */
        static bool isValidDate(std::tm);

        /**
         * Returns the current time according to the localtime setting in the system.
         * return Current time represented in std::tm format.
         */
        static std::tm getCurrentTime();

        /**
         * Compare the two times and return int value that represents the comparison result.
         * @param[in]   startdate Date that is supposed to be earlier.
         * @param[in]   enddate Date that is supposed to be later.
         * return Positive int represents startdate is earlier than enddate. Negative represents the opposite. 0 represents equal.
         */
        static int compareTime(std::tm startdate, std::tm enddate);
    };
}
```
###### DoLahTest\CommandUnitTest.cpp
``` cpp
        TEST_METHOD(SearchDateTaskCommand) {
            //Arrange
            DoLah::Calendar testCal;
            std::vector<std::string> commands = {
                "add task1 by next week",
                "add task2 in 2 weeks",
                "add task3 from today to next week",
                "done 3"
            };

            DoLah::AbstractCommand* command;
            for (size_t i = 0; i < commands.size(); i++) {
                command = DoLah::CommandParser::parse(commands[i]);
                command->setCalendar(&testCal);
                command->execute();
            }

            //Act
            command = DoLah::CommandParser::parse("search in 10 days");
            command->setCalendar(&testCal);
            command->execute();

            //Assert
            std::vector<DoLah::AbstractTask*> resultVector = testCal.getSearchedTaskList(); 
            Assert::AreEqual((size_t)2, resultVector.size());
        }

```
###### DoLahTest\ParserUnitTest.cpp
``` cpp
#include "stdafx.h"
#include "CppUnitTest.h"
#include "regex"
#include <iterator>
#include <functional>
#include <stdexcept>

#include "Parser/ParserLibrary.h"
#include "Parser/CommandParser.h"
#include "Parser/TaskParser.h"
#include "Parser/TaskTokenizer.h"
#include "Parser/DateTimeParser.h"

#include "Commands/Command.h"
#include "Models/Task.h"

#include "CalendarBuilder.h"
#include "TaskBuilder.h"
#include "TimeManager.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace DoLahTest {
    TEST_CLASS(Parser) {
private:
    std::tm current;
    int year;
    int month;
    int day;
    int nextYear;
    int nextMonth;
    int nextDay;
    int hour;
    int min;
    int remainderDays;
public:
    std::string tmToString(std::tm time) {
        return ""
            + std::to_string(time.tm_hour) + ":"
            + std::to_string(time.tm_min) + ":"
            + std::to_string(time.tm_sec) + " "
            + std::to_string(time.tm_mday) + "/"
            + std::to_string(time.tm_mon + 1) + "/"
            + std::to_string(time.tm_year + 1900);
    }

    std::string strfyTime(int hour, int min, int sec, int day, int month, int year) {
        return ""
            + std::to_string(hour) + ":"
            + std::to_string(min) + ":"
            + std::to_string(sec) + " "
            + std::to_string(day) + "/"
            + std::to_string(month) + "/"
            + std::to_string(year)
            ;
    }

    void parseTaskMethod(std::string input, std::vector<std::string> expected) {
        try {
            std::vector<std::string> inputArr = DoLah::ParserLibrary::explode(input, " ");
            std::vector<std::tm> datesVector = DoLah::TaskTokenizer::findAndRemoveDate(inputArr);
            std::string dates = "";
            if (!datesVector.empty()) {
                for (size_t i = 0; i < datesVector.size(); i++) {
                    dates += tmToString(datesVector.at(i));
                    if (i < datesVector.size() - 1) {
                        dates += " ~ ";
                    }
                }
            }
            std::string tags = DoLah::ParserLibrary::vectorToString(DoLah::TaskTokenizer::findTags(inputArr));
            std::string description = DoLah::TaskTokenizer::findDescription(inputArr);

            std::vector<std::string> actual = { dates, tags, description };
            AreEqualStringVectors(expected, actual);
        } catch (std::exception e) {
            throw e;
        }
    }

    void AreEqualStringVectors(std::vector<std::string> expected, std::vector<std::string> actual) {
        for (size_t i = 0; i < expected.size(); i++) {
            Assert::AreEqual(expected.at(i), actual.at(i));
        }
    }

    int getRemainderDaysOfTheMonth() {
        int count = 0;
        std::tm day = current;
        while (current.tm_mon == day.tm_mon) {
            day.tm_mday += 1;
            mktime(&day);
            count += 1;
        }

        return count - 1;
    }

    std::string UNHANDLED_COMMAND_MESSAGE = "Command not handled";
    std::string UNKNOWN_COMMAND_MESSAGE = "Command not recognized";
    std::string TOO_MANY_ARGUMENTS_MESSAGE = "Too many arguments";
    std::string TOO_LITTLE_ARGUMENTS_MESSAGE = "Too little arguments";
    std::string INVALID_TASK_ID_ARGUMENT = "Invalid task ID given";

    std::string UNEXPECTED_EXCEPTION = "This is an unexpected exception.";

    TEST_METHOD_INITIALIZE(Startup) {
        current = DoLah::TimeManager::getCurrentTime();

        year = current.tm_year + 1900;
        nextYear = current.tm_year + 1900 + 1;
        month = current.tm_mon + 1;
        nextMonth = current.tm_mon + 1 + 1;
        day = current.tm_mday;
        nextDay = current.tm_mday + 1;
        hour = current.tm_hour;
        min = current.tm_min;

        remainderDays = getRemainderDaysOfTheMonth();
    }

    // From here, unit tests for time parsing
    // Test for corner cases.
    TEST_METHOD(DateInDifferentFormat1) {
        std::string input = "24.12.2015";
        std::string expected = strfyTime(23, 59, 0, 24, 12, 2015);
        std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
        Assert::AreEqual(expected, actual);
    }

    TEST_METHOD(DateInDifferentFormat2) {
        std::string input = "24-12-2015";
        std::string expected = strfyTime(23, 59, 0, 24, 12, 2015);
        std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
        Assert::AreEqual(expected, actual);
    }

    // From here, integrated tests for task parsing
    // Does test for combination of multiple inputs

    TEST_METHOD(FloatingWithName) {
        parseTaskMethod((std::string)
            "task",
            { "", "{  }", "task" }
        );
    }

    TEST_METHOD(DeadlineWithName) {
        parseTaskMethod((std::string)
            "task on 24.12.2015",
            { strfyTime(23, 59, 0, 24, 12, 2015), "{  }", "task" }
        );
    }

    TEST_METHOD(EventWithName) {
        parseTaskMethod((std::string)
            "task from 24.12.2015 to 25.12.2015",
            { strfyTime(23, 59, 0, 24, 12, 2015) + " ~ " + strfyTime(23, 59, 0, 25, 12, 2015), "{  }", "task" }
        );
    }

    TEST_METHOD(EventWithNameAndTag) {
        parseTaskMethod((std::string)
            "#task from 24.12.2015 until 25.12.2015",
            { strfyTime(23, 59, 0, 24, 12, 2015) + " ~ " + strfyTime(23, 59, 0, 25, 12, 2015), "{ task }", "#task" }
        );
    }

    TEST_METHOD(EventWithNameAndMultipleTags) {
        parseTaskMethod((std::string)
            "#cs2103 #task from 24.12.2015 until 25.12.2015",
            { strfyTime(23, 59, 0, 24, 12, 2015) + " ~ " + strfyTime(23, 59, 0, 25, 12, 2015), "{ task, cs2103 }", "#cs2103 #task" }
        );
    }

    TEST_METHOD(WrongYearInDMY) {
        parseTaskMethod((std::string)
            "task on 24th of December 20150",
            { "", "{  }", "task on 24th of December 20150" }
        );
    }

    TEST_METHOD(WrongMonthInDMY) {
        parseTaskMethod((std::string)
            "task on 24th of Decemberu",
            { "", "{  }", "task on 24th of Decemberu" }
        );
    }

    TEST_METHOD(WrongDayInDMY) {
        parseTaskMethod((std::string)
            "task on 24the",
            { "", "{  }", "task on 24the" }
        );
    }

    TEST_METHOD(MonthWithoutDayInMDY) {
        parseTaskMethod((std::string)
            "task on December",
            { "", "{  }", "task on December" }
        );
    }

    TEST_METHOD(WrongMonthInMDY) {
        parseTaskMethod((std::string)
            "task on Decemberu 24th",
            { "", "{  }", "task on Decemberu 24th" }
        );
    }

    TEST_METHOD(WrongDayInMDY) {
        parseTaskMethod((std::string)
            "task on December 24the",
            { "", "{  }", "task on December 24the" }
        );
    }

    TEST_METHOD(WrongYearInMDY) {
        parseTaskMethod((std::string)
            "task on December 24th 20150",
            { "", "{  }", "task on December 24th 20150" }
        );
    }


    // From here, integrated tests for command parsing
    // Will check boundary cases and exceptions.
    // The actual content of the commands are hidden as black box.

    TEST_METHOD(WellDefinedAddCommandWithDeadline) {
        std::string input = "add #cs2103 #homework on 30th December 2015";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(true);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(UNEXPECTED_EXCEPTION, (std::string) e.what());
        }
    }

    TEST_METHOD(WellDefinedAddCommandWithEvent) {
        std::string input = "add #cs2103 #homework from 30th Dec 2015 to 31st Dec 2015";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(true);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(UNEXPECTED_EXCEPTION, (std::string) e.what());
        }
    }

    TEST_METHOD(AddCommandWithoutDescription) {
        std::string input = "add ";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(false);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(TOO_LITTLE_ARGUMENTS_MESSAGE, (std::string) e.what());
        }
    }

    TEST_METHOD(WellDefinedEditCommand) {
        std::string input = "edit 100 #cs2103 #homework on the #stage";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(true);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(UNEXPECTED_EXCEPTION, (std::string) e.what());
        }
    }

    TEST_METHOD(EditCommandWithoutTaskIndex) {
        std::string input = "edit #cs2103 #homework on the #stage";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(false);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(INVALID_TASK_ID_ARGUMENT, (std::string) e.what());
        }
    }

    TEST_METHOD(EditCommandWithoutTaskDescription) {
        std::string input = "edit 100";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(false);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(TOO_LITTLE_ARGUMENTS_MESSAGE, (std::string) e.what());
        }
    }

    TEST_METHOD(WellDefinedSearchCommand) {
        std::string input = "search me";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(true);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(UNEXPECTED_EXCEPTION, (std::string) e.what());
        }
    }

    TEST_METHOD(SearchCommandWithoutDescription) {
        std::string input = "search ";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(false);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(TOO_LITTLE_ARGUMENTS_MESSAGE, (std::string) e.what());
        }
    }

    TEST_METHOD(WellDefinedDeleteCommand) {
        std::string input = "delete 100";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(true);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(UNEXPECTED_EXCEPTION, (std::string) e.what());
        }
    }

    TEST_METHOD(DeleteCommandWithTooManyArguments) {
        std::string input = "delete 100 wow";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(false);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(TOO_MANY_ARGUMENTS_MESSAGE, (std::string) e.what());
        }
    }

    TEST_METHOD(DeleteCommandWithWrongTaskIndex) {
        std::string input = "delete wow";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(false);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(INVALID_TASK_ID_ARGUMENT, (std::string) e.what());
        }
    }

    TEST_METHOD(DeleteCommandWithoutTaskIndex) {
        std::string input = "delete ";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(false);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(TOO_LITTLE_ARGUMENTS_MESSAGE, (std::string) e.what());
        }
    }

    TEST_METHOD(WellDefinedClearCommand) {
        std::string input = "clear ";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(true);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(UNEXPECTED_EXCEPTION, (std::string) e.what());
        }
    }

    TEST_METHOD(ClearCommandWithTooManyArguments) {
        std::string input = "clear wow";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(false);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(TOO_MANY_ARGUMENTS_MESSAGE, (std::string) e.what());
        }
    }

    TEST_METHOD(WellDefinedUndoCommand) {
        std::string input = "undo ";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(true);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(UNEXPECTED_EXCEPTION, (std::string) e.what());
        }
    }

    // From here, integrated test on special cases of 'toDateFormat' for relative time descriptions.
    // The time will auto-filled, and the behaviour changes depending on the time of running.
    // Test will be disabled in a certain condition where it cannot run properly.
    TEST_METHOD(DateGivenDayAndMonth) {
        if (month == 1 && day == 1) {
            Assert::IsTrue(true);
        } else { // test will not function in every new year
            std::string input = "1st January";
            std::string expected = strfyTime(23, 59, 0, 1, 1, nextYear);
            std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
            Assert::AreEqual(expected, actual);
        }
    }

    TEST_METHOD(DateGivenDay) {
        if (day == 1) {
            Assert::IsTrue(true);
        } else { // test will not function on the 1st of every month
            std::string input = "1st";
            std::string expected = strfyTime(23, 59, 0, 1, nextMonth, year);
            std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
            Assert::AreEqual(expected, actual);
        }
    }

    TEST_METHOD(DateGivenMonthAndDay) {
        if (month == 1 && day == 1) {
            Assert::IsTrue(true);
        } else { // test will not function in every new year
            std::string input = "January 1st";
            std::string expected = strfyTime(23, 59, 0, 1, 1, nextYear);
            std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
            Assert::AreEqual(expected, actual);
        }
    }

    TEST_METHOD(TestTomorrow) {
        if (remainderDays < 1) {
            Assert::IsTrue(true);
        } else { // test will not function on the last day of the month
            std::string input = "tomorrow";
            std::string expected = strfyTime(23, 59, 0, nextDay, month, year);
            std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
            Assert::AreEqual(expected, actual);
        }
    }

    TEST_METHOD(TestNextWeek) {
        if (remainderDays < 7) {
            Assert::IsTrue(true);
        } else { // test will not function on the last week of the month
            std::string input = "next week";
            std::string expected = strfyTime(23, 59, 0, day + 7, month, year);
            std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
            Assert::AreEqual(expected, actual);
        }
    }

    TEST_METHOD(TestIn2Days) {
        if (remainderDays < 2) {
            Assert::IsTrue(true);
        } else { // test will not function in the last 2 days of the month
            std::string input = "2 days";
            std::string expected = strfyTime(23, 59, 0, day + 2, month, year);
            std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
            Assert::AreEqual(expected, actual);
        }
    }

    TEST_METHOD(TestIn1Weeks) {
        if (remainderDays < 7) {
            Assert::IsTrue(true);
        } else { // test will not function in the last 1 weeks of the month
            std::string input = "1 week";
            std::string expected = strfyTime(23, 59, 0, day + 7, month, year);
            std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
            Assert::AreEqual(expected, actual);
        }
    }

    TEST_METHOD(TestAt1159PM) {
        if (hour == 23 && min == 59) {
            Assert::IsTrue(true);
        } else { // test will not function at 11:59:00
            std::string input = "11:59PM";
            std::string expected = strfyTime(23, 59, 0, day, month, year);
            std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
            Assert::AreEqual(expected, actual);
        }
    }

    TEST_METHOD(TestAt2359PM) {
        if (hour == 23 && min == 59) {
            Assert::IsTrue(true);
        } else { // test will not function at 11:59:00
            std::string input = "23:59PM";
            std::string expected = strfyTime(23, 59, 0, day, month, year);
            std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
            Assert::AreEqual(expected, actual);
        }
    }

    TEST_METHOD(TestAt2359) {
        if (hour == 23 && min == 59) {
            Assert::IsTrue(true);
        } else { // test will not function at 11:59:00
            std::string input = "23:59";
            std::string expected = strfyTime(23, 59, 0, day, month, year);
            std::string actual = tmToString(DoLah::DateTimeParser::toDateFormat(DoLah::ParserLibrary::explode(input, " ")));
            Assert::AreEqual(expected, actual);
        }
    }

    TEST_METHOD(ParseSetDoneCommand) {

        // Arrange
        std::string input = "done 1";

        // Act
        DoLah::AbstractCommand* cmd = DoLah::CommandParser::parse(input);

        // Assert
        Assert::AreEqual(typeid(DoLah::SetDoneTaskCommand).name(), typeid(*cmd).name());
    }

    TEST_METHOD(ParseIncompleteSetDoneCommand) {

        // Arrange
        std::string input = "done";

        // Act
        std::function<DoLah::AbstractCommand* (void)> func = [input] {
            return DoLah::CommandParser::parse(input);
        };

        // Assert
        Assert::ExpectException<std::invalid_argument>(func);
    }

    TEST_METHOD(ParseTooManyArgumentSetDoneCommand) {

        // Arrange
        std::string input = "done task 1";

        // Act
        std::function<DoLah::AbstractCommand* (void)> func = [input] {
            return DoLah::CommandParser::parse(input);
        };

        // Assert
        Assert::ExpectException<std::invalid_argument>(func);
    }

    TEST_METHOD(ParseInvalidArgumentSetDoneCommand) {

        // Arrange
        std::string input = "done -1";

        // Act
        std::function<DoLah::AbstractCommand* (void)> func = [input] {
            return DoLah::CommandParser::parse(input);
        };

        // Assert
        Assert::ExpectException<std::invalid_argument>(func);
    }

    TEST_METHOD(stripTest) {
        std::string input = " search ";
        std::string expected = "search";
        std::string actual = DoLah::ParserLibrary::strip(input);
        Assert::AreEqual(expected, actual);
    }

    TEST_METHOD(UndoCommandWithTooManyArguments) {
        std::string input = "undo wow";
        try {
            DoLah::CommandParser::parse(input);
            Assert::IsTrue(false);
        } catch (std::invalid_argument e) {
            Assert::AreEqual(TOO_MANY_ARGUMENTS_MESSAGE, (std::string) e.what());
        }
    }

    };
}

```
